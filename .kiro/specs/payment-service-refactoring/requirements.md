# Требования к рефакторингу Payment Service после миграции Auth Service

## Введение

После успешной миграции функционала аутентификации в отдельный Auth Service, Payment Service требует комплексного рефакторинга для удаления дублирующего кода аутентификации, оптимизации интеграций с микросервисами и улучшения архитектуры. Сервис должен сосредоточиться исключительно на обработке платежей и заказов, делегируя аутентификацию Auth Service.

## Глоссарий

- **Payment_Service**: Микросервис обработки платежей и заказов
- **Auth_Service**: Новый микросервис аутентификации и авторизации
- **User_Service**: Микросервис управления пользователями
- **Game_Catalog_Service**: Микросервис каталога игр
- **Library_Service**: Микросервис библиотеки пользователей
- **Redis_Cache**: Общий Redis для кэширования между сервисами
- **JWT_Token**: JSON Web Token для аутентификации
- **Payment_Provider**: Внешний платежный провайдер (Сбербанк, ЮMoney, Т-Банк)

## Требования

### Требование 1 (Удаление локальной аутентификации)

**Пользовательская история:** Как разработчик, я хочу чтобы Payment Service не содержал собственного кода аутентификации, чтобы избежать дублирования и упростить архитектуру.

#### Критерии приемки

1. КОГДА проверяется код сервиса ТОГДА Payment_Service НЕ ДОЛЖЕН содержать JWT стратегии
2. КОГДА анализируются зависимости ТОГДА Payment_Service НЕ ДОЛЖЕН содержать passport, passport-jwt пакеты
3. КОГДА просматриваются guards ТОГДА Payment_Service НЕ ДОЛЖЕН содержать JwtAuthGuard
4. ЕСЛИ найдены остатки auth кода ТОГДА Payment_Service ДОЛЖЕН их полностью удалить

### Требование 2 (Интеграция с Auth Service)

**Пользовательская история:** Как Payment Service, я хочу валидировать токены через Auth Service, чтобы обеспечить централизованную аутентификацию.

#### Критерии приемки

1. КОГДА приходит запрос с JWT токеном ТОГДА Payment_Service ДОЛЖЕН валидировать токен через Auth_Service
2. КОГДА Auth_Service подтверждает токен ТОГДА Payment_Service ДОЛЖЕН получить данные пользователя
3. КОГДА токен недействителен ТОГДА Payment_Service ДОЛЖЕН вернуть ошибку 401
4. ЕСЛИ Auth_Service недоступен ТОГДА Payment_Service ДОЛЖЕН использовать fallback механизм

### Требование 3 (Оптимизация интеграций с микросервисами)

**Пользовательская история:** Как Payment Service, я хочу эффективно взаимодействовать с другими микросервисами через стандартизированные интерфейсы.

#### Критерии приемки

1. КОГДА создается заказ ТОГДА Payment_Service ДОЛЖЕН валидировать игру через Game_Catalog_Service за < 100ms
2. КОГДА платеж подтверждается ТОГДА Payment_Service ДОЛЖЕН добавить игру в Library_Service за < 200ms
3. КОГДА требуются данные пользователя ТОГДА Payment_Service ДОЛЖЕН запрашивать их через User_Service
4. ЕСЛИ внешний сервис недоступен ТОГДА Payment_Service ДОЛЖЕН корректно обрабатывать ошибки

### Требование 4 (Использование общего Redis)

**Пользовательская история:** Как часть общей платформы, я хочу использовать общий Redis для кэширования и сессий между микросервисами.

#### Критерии приемки

1. КОГДА Payment_Service кэширует данные ТОГДА система ДОЛЖНА использовать общий Redis_Cache
2. КОГДА кэшируются данные игр ТОГДА система ДОЛЖНА использовать TTL 300 секунд
3. КОГДА кэшируются результаты валидации ТОГДА система ДОЛЖНА использовать TTL 60 секунд
4. ЕСЛИ Redis_Cache недоступен ТОГДА Payment_Service ДОЛЖЕН работать без кэширования

### Требование 5 (Улучшение обработки платежей)

**Пользовательская история:** Как пользователь, я хочу чтобы платежи обрабатывались быстро и надежно через российские платежные системы.

#### Критерии приемки

1. КОГДА создается платеж ТОГДА Payment_Service ДОЛЖЕН поддерживать все Payment_Provider (Сбербанк, ЮMoney, Т-Банк)
2. КОГДА обрабатывается webhook ТОГДА Payment_Service ДОЛЖЕН валидировать подпись провайдера
3. КОГДА платеж завершается ТОГДА Payment_Service ДОЛЖЕН обновить статус за < 100ms
4. ЕСЛИ провайдер недоступен ТОГДА Payment_Service ДОЛЖЕН повторить попытку через 30 секунд

### Требование 6 (Оптимизация производительности)

**Пользовательская история:** Как система, я хочу чтобы Payment Service обрабатывал платежи с минимальной задержкой для поддержки высокой нагрузки.

#### Критерии приемки

1. КОГДА создается заказ ТОГДА Payment_Service ДОЛЖЕН отвечать за < 200ms
2. КОГДА обрабатывается платеж ТОГДА Payment_Service ДОЛЖЕН использовать connection pooling
3. КОГДА происходит пиковая нагрузка ТОГДА Payment_Service ДОЛЖЕН поддерживать 1000 одновременных запросов
4. ЕСЛИ база данных перегружена ТОГДА Payment_Service ДОЛЖЕН использовать read replicas

### Требование 7 (Улучшение мониторинга и логирования)

**Пользовательская история:** Как DevOps инженер, я хочу мониторить Payment Service и быстро диагностировать проблемы с платежами.

#### Критерии приемки

1. КОГДА происходит платежная операция ТОГДА Payment_Service ДОЛЖЕН логировать метрики с correlation ID
2. КОГДА возникает ошибка платежа ТОГДА Payment_Service ДОЛЖЕН логировать детальную информацию
3. КОГДА проверяется здоровье сервиса ТОГДА Payment_Service ДОЛЖЕН проверять все Payment_Provider
4. ЕСЛИ производительность деградирует ТОГДА Payment_Service ДОЛЖЕН отправлять алерты

### Требование 8 (Стандартизация API)

**Пользовательская история:** Как фронтенд разработчик, я хочу использовать консистентный API для работы с платежами и заказами.

#### Критерии приемки

1. КОГДА вызывается любой endpoint ТОГДА Payment_Service ДОЛЖЕН возвращать стандартизированный формат ответа
2. КОГДА происходит ошибка ТОГДА Payment_Service ДОЛЖЕН возвращать единообразные коды ошибок
3. КОГДА используется пагинация ТОГДА Payment_Service ДОЛЖЕН поддерживать стандартные параметры
4. ЕСЛИ требуется фильтрация заказов ТОГДА Payment_Service ДОЛЖЕН поддерживать query параметры

### Требование 9 (Безопасность платежных операций)

**Пользовательская история:** Как пользователь, я хочу чтобы мои платежные данные были защищены согласно требованиям PCI DSS.

#### Критерии приемки

1. КОГДА обрабатываются платежные данные ТОГДА Payment_Service ДОЛЖЕН шифровать чувствительную информацию
2. КОГДА происходит webhook от провайдера ТОГДА Payment_Service ДОЛЖЕН валидировать подпись
3. КОГДА логируются операции ТОГДА Payment_Service НЕ ДОЛЖЕН логировать платежные данные
4. ЕСЛИ обнаружена подозрительная активность ТОГДА Payment_Service ДОЛЖЕН заблокировать операцию

### Требование 10 (Интеграция с общим CI/CD)

**Пользовательская история:** Как DevOps инженер, я хочу чтобы Payment Service интегрировался с общим CI/CD процессом платформы.

#### Критерии приемки

1. КОГДА происходит push в репозиторий ТОГДА Payment_Service ДОЛЖЕН запускать тесты через общий GitHub Actions workflow
2. КОГДА тесты проходят ТОГДА Payment_Service ДОЛЖЕН автоматически собирать Docker образ
3. КОГДА образ готов ТОГДА Payment_Service ДОЛЖЕН деплоиться в общую инфраструктуру
4. ЕСЛИ тесты не проходят ТОГДА Payment_Service ДОЛЖЕН блокировать деплой и уведомлять команду

### Требование 11 (Совместимость с общей инфраструктурой)

**Пользовательская история:** Как часть общей платформы, я хочу чтобы Payment Service использовал общие сервисы и конфигурации.

#### Критерии приемки

1. КОГДА сервис запускается ТОГДА Payment_Service ДОЛЖЕН подключаться к общему PostgreSQL из docker-compose.yml
2. КОГДА требуется кэширование ТОГДА Payment_Service ДОЛЖЕН использовать общий Redis_Cache
3. КОГДА происходит деплой ТОГДА Payment_Service ДОЛЖЕН использовать общие Kubernetes конфигурации
4. ЕСЛИ общие сервисы недоступны ТОГДА Payment_Service ДОЛЖЕН корректно обрабатывать ошибки

### Требование 12 (Оптимизация webhook обработки)

**Пользовательская история:** Как платежный провайдер, я хочу чтобы Payment Service быстро и надежно обрабатывал webhook уведомления.

#### Критерии приемки

1. КОГДА приходит webhook от Payment_Provider ТОГДА Payment_Service ДОЛЖЕН обработать его за < 500ms
2. КОГДА webhook обрабатывается ТОГДА Payment_Service ДОЛЖЕН валидировать подпись провайдера
3. КОГДА webhook дублируется ТОГДА Payment_Service ДОЛЖЕН обнаруживать повторные запросы
4. ЕСЛИ обработка webhook не удалась ТОГДА Payment_Service ДОЛЖЕН логировать ошибку и повторить попытку